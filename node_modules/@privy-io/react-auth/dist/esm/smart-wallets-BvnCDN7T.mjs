import{useRef as e,useState as n,useCallback as t}from"react";import{http as a,createPublicClient as r}from"viem";import{q as i,u as s,r as o,E as l,ac as c,M as d}from"./useWallets-0lCjD0UF.mjs";import{P as u,u as p}from"./internal-context-DBDJ7qsa.mjs";import{a as m}from"./getPublicClient-BghjDv1y.mjs";import{g as y}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{createSmartAccountClient as E}from"permissionless";import{toThirdwebSmartAccount as f,toLightSmartAccount as g,toBiconomySmartAccount as I,toEcdsaKernelSmartAccount as h,toSafeSmartAccount as w}from"permissionless/accounts";import{createPimlicoClient as C}from"permissionless/clients/pimlico";import{toCoinbaseSmartAccount as P,entryPoint06Address as T,entryPoint07Address as D}from"viem/account-abstraction";import{THIRDWEB as _,COINBASE_SMART_WALLET as N,LIGHT_ACCOUNT as W,BICONOMY as S,KERNEL as v,SAFE as F}from"@privy-io/js-sdk-core";let x={address:T,version:"0.6"},G={address:D,version:"0.7"},M=({owner:e,smartWalletType:n,publicClient:t})=>{switch(n){case F:return w({client:t,entryPoint:G,owners:[e],version:"1.4.1"});case v:return h({client:t,version:"0.3.1",entryPoint:G,owners:[e]});case S:return I({client:t,owners:[e],entryPoint:x});case W:return g({client:t,entryPoint:x,owner:e,version:"1.1.0"});case N:return async function({client:e,owner:n}){let[t]=await n.request({method:"eth_accounts"});if(!t)throw Error("Unable to request embedded owner for eth_accounts");return await P({client:e,owners:[{type:"local",source:"privy",address:t,sign:async({hash:e})=>await n.request({method:"secp256k1_sign",params:[e]})}]})}({client:t,owner:e});case _:return f({client:t,entryPoint:G,owner:e});default:throw Error(`Invalid smart account type: ${n}.`)}},b=["rpc.zerodev.app","public.pimlico.io","api.pimlico.io"];const A=({calls:e,chain:n,maxPriorityFeePerGas:t,maxFeePerGas:a,nonce:r})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:n.id,nonce:r,maxFeePerGas:a,maxPriorityFeePerGas:t}))),O=async({chain:e,paymasterContext:n,embeddedWallet:t,user:i,smartWalletsConfig:s,rpcConfig:o,privyAppId:l})=>{if(!s?.enabled||!i||!t)return;let c=await t.getEthereumProvider(),d=s?.configuredNetworks.find((n=>n.chainId===`eip155:${e.id}`));if(!d)throw new u(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let p=i.smartWallet?.smartWalletType??s.smartWalletType,y=m(e,o,l),f=r({chain:e,transport:a(y)}),g=n??d.paymasterContext,I=await(async({owner:e,smartWalletType:n,chain:t,publicClient:r,bundlerUrl:i,paymasterUrl:s,paymasterContext:o})=>{let l=await M({owner:e,smartWalletType:n,publicClient:r}),c=C({transport:a(i),entryPoint:l.entryPoint}),d=s?C({transport:a(s),entryPoint:l.entryPoint}):void 0;return E({account:l,chain:t,paymaster:d,paymasterContext:o,bundlerTransport:a(i),userOperation:{estimateFeesPerGas:async()=>{if(b.some((e=>i.includes(e))))return await c.getUserOperationGasPrice().then((e=>e.fast));{let e=await r.estimateFeesPerGas(),n=i.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*n/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*n/100n}}}}})})({owner:c,smartWalletType:p,chain:e,publicClient:f,paymasterContext:g,...d});if(!I)throw new u(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return I},L=({clientConfig:a,smartWalletsConfig:r})=>{let{hideWalletUIs:m,openPrivyModal:E,appId:f}=p(),g=i(),{setModalData:I}=s(),{user:h}=o(),{chains:w}=i(),{chainId:C,clients:P,setChainId:T,chainIdState:D}=(()=>{let t=e(),[a,r]=n();return{clients:e({}),setChainId:e=>{t.current=e,r(e)},chainId:t,chainIdState:a}})(),_=w.find((e=>e.id===D)),{wallets:N}=l(),W=t((async()=>C.current),[C]),S=t((async({id:e})=>{if(!P.current[e]){let n=y(N),t=await O({chain:w.find((n=>n.id===e)),embeddedWallet:n,user:h,paymasterContext:a?.paymasterContext,smartWalletsConfig:r,rpcConfig:g.rpcConfig,privyAppId:f});t&&(P.current[e]=t)}T(e)}),[w,a,N,h,r]);return{wrapSmartAccountClient:e=>{P.current[e.chain.id]=e,D||T(e.chain.id);return{...e,sendTransaction:async(e,n)=>{let t=P.current[C.current];if(!t)throw new u(`Smart wallet client for chain (eip155:${C.current}) not found`);if(delete e.account,!g.embeddedWallets.showWalletUIs)return m.current=!0,await t.sendTransaction(e).finally((()=>m.current=!1));let a=[];"calls"in e&&void 0!==e.calls?a=[...e.calls]:"to"in e&&(a=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let r=async()=>{if(!t.paymaster)return!1;let{paymasterAndData:n,paymasterData:r}=await t.prepareUserOperation({calls:a,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return Number(n??r??0)>0};return new Promise((async(i,s)=>{m.current=!0;let{entropyId:o,entropyIdVerifier:l}=c(h);I({connectWallet:{entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:d.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:A({calls:a,chain:t.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:o,entropyIdVerifier:l,transactingWallet:{address:t.account.address,walletIndex:null},getIsSponsored:r,signOnly:!1,onConfirm:()=>t.sendTransaction(e),onSuccess:e=>i(e.hash),onFailure:s,uiOptions:n?.uiOptions??{}}}),E(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{m.current=!1}))},signMessage:async(e,n)=>{let t=P.current[C.current];if(!t)throw new u(`Smart wallet client for chain (eip155:${C.current}) not found`);return g.embeddedWallets.showWalletUIs?new Promise((async(a,r)=>{let{entropyId:i,entropyIdVerifier:s}=c(h);m.current=!0,I({connectWallet:{entropyId:i,entropyIdVerifier:s,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>t.signMessage(e),onSuccess:e=>a(e),onFailure:r,uiOptions:n?.uiOptions??{}}}),E(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{m.current=!1})):(m.current=!0,await t.signMessage(e).finally((()=>m.current=!1)))},signTypedData:async(e,n)=>{let t=P.current[C.current];if(!t)throw new u(`Smart wallet client for chain (eip155:${C.current}) not found`);return delete e.account,g.embeddedWallets.showWalletUIs?new Promise((async(a,r)=>{m.current=!0;let{entropyId:i,entropyIdVerifier:s}=c(h);I({connectWallet:{entropyId:i,entropyIdVerifier:s,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>t.signTypedData(e),onSuccess:e=>a(e),onFailure:r,uiOptions:n?.uiOptions??{}}}),E(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{m.current=!1})):(m.current=!0,await t.signTypedData(e).finally((()=>m.current=!1)))},getChainId:W,chain:_,switchChain:S}}}},R=()=>{let{hideWalletUIs:e,openPrivyModal:n}=p(),t=i(),{setModalData:a}=s(),{user:r}=o();return{wrapSmartAccountClientWithUIs:i=>({...i,sendTransaction:async(s,o)=>{if(!t.embeddedWallets.showWalletUIs)return e.current=!0,await i.sendTransaction(s).finally((()=>e.current=!1));let l=[];"calls"in s&&void 0!==s.calls?l=[...s.calls]:"to"in s&&(l=[{to:s.to,value:s.value||BigInt(0),data:s.data||"0x"}]);let u=async()=>{if(!i.paymaster)return!1;let{paymasterAndData:e,paymasterData:n}=await i.prepareUserOperation({calls:l,maxFeePerGas:s.maxFeePerGas,maxPriorityFeePerGas:s.maxPriorityFeePerGas,nonce:s.nonce?BigInt(s.nonce):void 0});return Number(e??n??0)>0};return new Promise((async(t,p)=>{e.current=!0;let{entropyId:m,entropyIdVerifier:y}=c(r);a({connectWallet:{entropyId:m,entropyIdVerifier:y,onCompleteNavigateTo:d.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:A({calls:l,chain:i.chain,maxPriorityFeePerGas:s.maxPriorityFeePerGas,maxFeePerGas:s.maxFeePerGas,nonce:s.nonce?BigInt(s.nonce):void 0}),entropyId:m,entropyIdVerifier:y,transactingWallet:{address:i.account.address,walletIndex:null},getIsSponsored:u,signOnly:!1,onConfirm:()=>i.sendTransaction(s),onSuccess:e=>t(e.hash),onFailure:p,uiOptions:o?.uiOptions??{}}}),n(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))},signMessage:async(s,o)=>t.embeddedWallets.showWalletUIs?new Promise((async(t,l)=>{let{entropyId:u,entropyIdVerifier:p}=c(r);e.current=!0,a({connectWallet:{entropyId:u,entropyIdVerifier:p,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof s.message?s.message:s.message.raw.toString(),confirmAndSign:()=>i.signMessage(s),onSuccess:e=>t(e),onFailure:l,uiOptions:o?.uiOptions??{}}}),n(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})):(e.current=!0,await i.signMessage(s).finally((()=>e.current=!1))),signTypedData:async(s,o)=>t.embeddedWallets.showWalletUIs?new Promise((async(t,l)=>{e.current=!0;let{entropyId:u,entropyIdVerifier:p}=c(r);a({connectWallet:{entropyId:u,entropyIdVerifier:p,onCompleteNavigateTo:d.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:s,confirmAndSign:()=>i.signTypedData(s),onSuccess:e=>t(e),onFailure:l,uiOptions:o?.uiOptions??{}}}),n(d.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})):(e.current=!0,await i.signTypedData(s).finally((()=>e.current=!1)))})}};export{L as a,A as c,O as g,R as u};
